--// Advanced Marketplace & Economy Exploits Module
--// Based on Remote Events Analysis from fdump.txt
--// Created: September 3, 2025

local Players = cloneref(game:GetService('Players'))
local ReplicatedStorage = cloneref(game:GetService('ReplicatedStorage'))
local RunService = cloneref(game:GetService('RunService'))
local HttpService = cloneref(game:GetService('HttpService'))
local MarketplaceService = cloneref(game:GetService('MarketplaceService'))

local lp = Players.LocalPlayer
local EconomyExploits = {}

--// Remote Events Storage (Based on fdump.txt)
EconomyExploits.RemoteEvents = {
    -- Daily Shop System
    DailyShop = {
        Open = nil,
        Purchase = nil,
        Refresh = nil,
        ReplicateItems = nil
    },
    
    -- Shell Merchant
    ShellMerchant = {
        Open = nil,
        Purchase = nil,
        ReplicateItems = nil
    },
    
    -- Commerce System
    Commerce = {
        TryBuy = nil,
        OpenGui = nil
    },
    
    -- Sales Booth System
    SalesBooth = {
        UpdateInfo = nil,
        RequestInfo = nil,
        Claim = nil,
        AddItem = nil,
        RemoveItem = nil,
        PurchaseItem = nil
    },
    
    -- Monetization System
    Monetization = {
        BuyProduct = nil,
        UpdateCreditsPrice = nil
    }
}

--// Data Storage
EconomyExploits.Data = {
    MarketPrices = {},
    ItemDatabase = {},
    ProfitableDeals = {},
    ShopInventories = {},
    PriceHistory = {},
    AutoBuyList = {},
    AutoSellList = {},
    FlipOpportunities = {},
    EconomyStats = {}
}

--// Configuration
EconomyExploits.Config = {
    MarketPriceManipulator = false,
    UnlimitedShopRefresh = false,
    AutoItemFlipper = false,
    FreePurchaseExploit = false,
    ShopInventoryScanner = false,
    MaxSpendAmount = 100000,
    MinProfitMargin = 0.20, -- 20% minimum profit
    RefreshDelay = 0.1,
    ScanDelay = 1,
    FlipDelay = 2,
    MaxPurchaseAttempts = 10,
    LogActivity = true
}

--// Helper Functions
local function safeFireRemote(remote, ...)
    local success, result = pcall(function()
        return remote:FireServer(...)
    end)
    if not success then
        warn("Failed to fire remote:", remote.Name, "Error:", result)
    end
    return success, result
end

local function safeInvokeRemote(remote, ...)
    local success, result = pcall(function()
        return remote:InvokeServer(...)
    end)
    if not success then
        warn("Failed to invoke remote:", remote.Name, "Error:", result)
    end
    return success, result
end

local function logActivity(activity, details)
    if not EconomyExploits.Config.LogActivity then return end
    local timestamp = os.date("%H:%M:%S")
    print(string.format("[%s] ECONOMY: %s - %s", timestamp, activity, details or ""))
end

local function calculateProfit(buyPrice, sellPrice)
    if buyPrice == 0 then return math.huge end
    return (sellPrice - buyPrice) / buyPrice
end

local function isItemProfitable(itemData)
    local profit = calculateProfit(itemData.buyPrice or 0, itemData.sellPrice or 0)
    return profit >= EconomyExploits.Config.MinProfitMargin
end

--// 1. MARKET PRICE MANIPULATOR
function EconomyExploits:StartMarketPriceManipulator()
    if self.Config.MarketPriceManipulator then return end
    self.Config.MarketPriceManipulator = true
    logActivity("PRICE", "Starting Market Price Manipulator")
    
    spawn(function()
        while self.Config.MarketPriceManipulator do
            self:ManipulateMarketPrices()
            wait(2)
        end
    end)
end

function EconomyExploits:StopMarketPriceManipulator()
    self.Config.MarketPriceManipulator = false
    logActivity("PRICE", "Stopping Market Price Manipulator")
end

function EconomyExploits:ManipulateMarketPrices()
    -- Method 1: Manipulate credit prices
    if self.RemoteEvents.Monetization.UpdateCreditsPrice then
        safeFireRemote(self.RemoteEvents.Monetization.UpdateCreditsPrice, 0, 999999)
        logActivity("PRICE", "Attempted to manipulate credit prices")
    end
    
    -- Method 2: Try to manipulate shop prices through purchase system
    local manipulationTargets = {
        "Rod", "Bait", "Bobber", "Boat", "Skin", "Crystal", "Gem"
    }
    
    for _, itemType in pairs(manipulationTargets) do
        self:AttemptPriceManipulation(itemType)
    end
end

function EconomyExploits:AttemptPriceManipulation(itemType)
    -- Try multiple manipulation methods
    local methods = {
        function() self:ManipulateViaBuyProduct(itemType) end,
        function() self:ManipulateViaCommerce(itemType) end,
        function() self:ManipulateViaSalesBooth(itemType) end
    }
    
    for _, method in pairs(methods) do
        pcall(method)
        wait(0.1)
    end
end

function EconomyExploits:ManipulateViaBuyProduct(itemType)
    if self.RemoteEvents.Monetization.BuyProduct then
        safeFireRemote(self.RemoteEvents.Monetization.BuyProduct, itemType, 0) -- Try to buy with 0 cost
    end
end

function EconomyExploits:ManipulateViaCommerce(itemType)
    if self.RemoteEvents.Commerce.TryBuy then
        safeFireRemote(self.RemoteEvents.Commerce.TryBuy, itemType, 0, 999) -- Try to buy 999 items for 0 cost
    end
end

function EconomyExploits:ManipulateViaSalesBooth(itemType)
    if self.RemoteEvents.SalesBooth.PurchaseItem then
        safeFireRemote(self.RemoteEvents.SalesBooth.PurchaseItem, itemType, 0)
    end
end

--// 2. UNLIMITED SHOP REFRESH
function EconomyExploits:StartUnlimitedShopRefresh()
    if self.Config.UnlimitedShopRefresh then return end
    self.Config.UnlimitedShopRefresh = true
    logActivity("REFRESH", "Starting Unlimited Shop Refresh")
    
    spawn(function()
        while self.Config.UnlimitedShopRefresh do
            self:RefreshAllShops()
            wait(self.Config.RefreshDelay)
        end
    end)
end

function EconomyExploits:StopUnlimitedShopRefresh()
    self.Config.UnlimitedShopRefresh = false
    logActivity("REFRESH", "Stopping Unlimited Shop Refresh")
end

function EconomyExploits:RefreshAllShops()
    -- Refresh Daily Shop
    if self.RemoteEvents.DailyShop.Refresh then
        safeFireRemote(self.RemoteEvents.DailyShop.Refresh)
    end
    
    -- Try to refresh other shop systems
    local shopTypes = {"DailyShop", "ShellMerchant", "SalesBooth"}
    
    for _, shopType in pairs(shopTypes) do
        self:RefreshSpecificShop(shopType)
    end
end

function EconomyExploits:RefreshSpecificShop(shopType)
    local refreshEvents = {
        DailyShop = self.RemoteEvents.DailyShop.Refresh,
        ShellMerchant = self.RemoteEvents.ShellMerchant.Open, -- Opening might refresh
        SalesBooth = self.RemoteEvents.SalesBooth.UpdateInfo
    }
    
    local event = refreshEvents[shopType]
    if event then
        safeFireRemote(event)
        logActivity("REFRESH", "Refreshed " .. shopType)
    end
end

function EconomyExploits:ForceRefreshShop(shopType, count)
    count = count or 10
    logActivity("REFRESH", "Force refreshing " .. shopType .. " " .. count .. " times")
    
    for i = 1, count do
        self:RefreshSpecificShop(shopType)
        wait(0.05) -- Very fast refresh
    end
end

--// 3. AUTO ITEM FLIPPER
function EconomyExploits:StartAutoItemFlipper()
    if self.Config.AutoItemFlipper then return end
    self.Config.AutoItemFlipper = true
    logActivity("FLIPPER", "Starting Auto Item Flipper")
    
    spawn(function()
        while self.Config.AutoItemFlipper do
            self:ScanForFlipOpportunities()
            self:ExecuteFlipTrades()
            wait(self.Config.FlipDelay)
        end
    end)
end

function EconomyExploits:StopAutoItemFlipper()
    self.Config.AutoItemFlipper = false
    logActivity("FLIPPER", "Stopping Auto Item Flipper")
end

function EconomyExploits:ScanForFlipOpportunities()
    -- Update shop inventories
    self:UpdateShopInventories()
    
    -- Analyze for profitable flips
    self:AnalyzeFlipOpportunities()
end

function EconomyExploits:UpdateShopInventories()
    -- Get Daily Shop items
    if self.RemoteEvents.DailyShop.ReplicateItems then
        safeFireRemote(self.RemoteEvents.DailyShop.ReplicateItems)
    end
    
    -- Get Shell Merchant items
    if self.RemoteEvents.ShellMerchant.ReplicateItems then
        safeFireRemote(self.RemoteEvents.ShellMerchant.ReplicateItems)
    end
    
    -- Get Sales Booth items
    if self.RemoteEvents.SalesBooth.RequestInfo then
        safeInvokeRemote(self.RemoteEvents.SalesBooth.RequestInfo)
    end
end

function EconomyExploits:AnalyzeFlipOpportunities()
    local opportunities = {}
    
    -- Compare prices across different shops
    for itemName, itemData in pairs(self.Data.ItemDatabase) do
        local buyPrice = self:GetLowestBuyPrice(itemName)
        local sellPrice = self:GetHighestSellPrice(itemName)
        
        if buyPrice and sellPrice then
            local profit = calculateProfit(buyPrice, sellPrice)
            if profit >= self.Config.MinProfitMargin then
                table.insert(opportunities, {
                    item = itemName,
                    buyPrice = buyPrice,
                    sellPrice = sellPrice,
                    profit = profit,
                    profitAmount = sellPrice - buyPrice
                })
            end
        end
    end
    
    -- Sort by profitability
    table.sort(opportunities, function(a, b)
        return a.profitAmount > b.profitAmount
    end)
    
    self.Data.FlipOpportunities = opportunities
    
    if #opportunities > 0 then
        logActivity("FLIPPER", "Found " .. #opportunities .. " flip opportunities")
    end
end

function EconomyExploits:GetLowestBuyPrice(itemName)
    local lowestPrice = math.huge
    local shops = {"DailyShop", "ShellMerchant", "SalesBooth"}
    
    for _, shop in pairs(shops) do
        local inventory = self.Data.ShopInventories[shop]
        if inventory and inventory[itemName] then
            lowestPrice = math.min(lowestPrice, inventory[itemName].price)
        end
    end
    
    return lowestPrice ~= math.huge and lowestPrice or nil
end

function EconomyExploits:GetHighestSellPrice(itemName)
    -- This would need to be implemented based on game's selling mechanics
    -- For now, use historical data or estimated values
    local priceHistory = self.Data.PriceHistory[itemName]
    if priceHistory then
        return priceHistory.maxPrice
    end
    return nil
end

function EconomyExploits:ExecuteFlipTrades()
    for _, opportunity in pairs(self.Data.FlipOpportunities) do
        if self:CanAffordItem(opportunity) then
            self:BuyItemForFlip(opportunity)
            wait(0.5)
            self:SellItemForFlip(opportunity)
            wait(1)
        end
    end
end

function EconomyExploits:CanAffordItem(opportunity)
    -- This would check player's current currency
    return opportunity.buyPrice <= self.Config.MaxSpendAmount
end

function EconomyExploits:BuyItemForFlip(opportunity)
    local purchased = false
    
    -- Try Daily Shop
    if self.RemoteEvents.DailyShop.Purchase then
        purchased = safeFireRemote(self.RemoteEvents.DailyShop.Purchase, opportunity.item, 1)
    end
    
    -- Try Shell Merchant
    if not purchased and self.RemoteEvents.ShellMerchant.Purchase then
        purchased = safeFireRemote(self.RemoteEvents.ShellMerchant.Purchase, opportunity.item, 1)
    end
    
    -- Try Commerce
    if not purchased and self.RemoteEvents.Commerce.TryBuy then
        purchased = safeFireRemote(self.RemoteEvents.Commerce.TryBuy, opportunity.item, opportunity.buyPrice, 1)
    end
    
    if purchased then
        logActivity("FLIP", "Bought " .. opportunity.item .. " for " .. opportunity.buyPrice)
    end
    
    return purchased
end

function EconomyExploits:SellItemForFlip(opportunity)
    -- Add item to sales booth
    if self.RemoteEvents.SalesBooth.AddItem then
        local success = safeFireRemote(self.RemoteEvents.SalesBooth.AddItem, opportunity.item, opportunity.sellPrice)
        if success then
            logActivity("FLIP", "Listed " .. opportunity.item .. " for " .. opportunity.sellPrice)
            return true
        end
    end
    
    return false
end

--// 4. FREE PURCHASE EXPLOIT
function EconomyExploits:StartFreePurchaseExploit()
    if self.Config.FreePurchaseExploit then return end
    self.Config.FreePurchaseExploit = true
    logActivity("FREE", "Starting Free Purchase Exploit")
    
    spawn(function()
        while self.Config.FreePurchaseExploit do
            self:AttemptFreePurchases()
            wait(5)
        end
    end)
end

function EconomyExploits:StopFreePurchaseExploit()
    self.Config.FreePurchaseExploit = false
    logActivity("FREE", "Stopping Free Purchase Exploit")
end

function EconomyExploits:AttemptFreePurchases()
    local valueableItems = {
        "Heaven Rod", "Kings Rod", "Divine Crystal", "Mythic Bait",
        "Legendary Bobber", "Guardian of Atlantis", "Celestial Skin"
    }
    
    for _, item in pairs(valueableItems) do
        self:AttemptFreePurchase(item)
        wait(0.5)
    end
end

function EconomyExploits:AttemptFreePurchase(itemName)
    local methods = {
        -- Method 1: Zero cost purchase
        function()
            if self.RemoteEvents.DailyShop.Purchase then
                return safeFireRemote(self.RemoteEvents.DailyShop.Purchase, itemName, 0)
            end
        end,
        
        -- Method 2: Negative cost
        function()
            if self.RemoteEvents.Commerce.TryBuy then
                return safeFireRemote(self.RemoteEvents.Commerce.TryBuy, itemName, -999, 1)
            end
        end,
        
        -- Method 3: Buy product with zero
        function()
            if self.RemoteEvents.Monetization.BuyProduct then
                return safeFireRemote(self.RemoteEvents.Monetization.BuyProduct, itemName, 0)
            end
        end,
        
        -- Method 4: Sales booth exploit
        function()
            if self.RemoteEvents.SalesBooth.PurchaseItem then
                return safeFireRemote(self.RemoteEvents.SalesBooth.PurchaseItem, itemName, 0)
            end
        end
    }
    
    for i, method in pairs(methods) do
        local success = method()
        if success then
            logActivity("FREE", "Free purchase successful: " .. itemName .. " (Method " .. i .. ")")
            break
        end
        wait(0.1)
    end
end

--// 5. SHOP INVENTORY SCANNER
function EconomyExploits:StartShopInventoryScanner()
    if self.Config.ShopInventoryScanner then return end
    self.Config.ShopInventoryScanner = true
    logActivity("SCANNER", "Starting Shop Inventory Scanner")
    
    spawn(function()
        while self.Config.ShopInventoryScanner do
            self:ScanAllShopInventories()
            self:AnalyzeMarketTrends()
            wait(self.Config.ScanDelay)
        end
    end)
end

function EconomyExploits:StopShopInventoryScanner()
    self.Config.ShopInventoryScanner = false
    logActivity("SCANNER", "Stopping Shop Inventory Scanner")
end

function EconomyExploits:ScanAllShopInventories()
    -- Open and scan Daily Shop
    self:ScanDailyShop()
    
    -- Open and scan Shell Merchant
    self:ScanShellMerchant()
    
    -- Scan Sales Booths
    self:ScanSalesBooths()
    
    -- Update market data
    self:UpdateMarketData()
end

function EconomyExploits:ScanDailyShop()
    if self.RemoteEvents.DailyShop.Open then
        safeFireRemote(self.RemoteEvents.DailyShop.Open)
        wait(0.5)
        
        if self.RemoteEvents.DailyShop.ReplicateItems then
            safeFireRemote(self.RemoteEvents.DailyShop.ReplicateItems)
        end
    end
end

function EconomyExploits:ScanShellMerchant()
    if self.RemoteEvents.ShellMerchant.Open then
        safeFireRemote(self.RemoteEvents.ShellMerchant.Open)
        wait(0.5)
        
        if self.RemoteEvents.ShellMerchant.ReplicateItems then
            safeFireRemote(self.RemoteEvents.ShellMerchant.ReplicateItems)
        end
    end
end

function EconomyExploits:ScanSalesBooths()
    if self.RemoteEvents.SalesBooth.RequestInfo then
        safeInvokeRemote(self.RemoteEvents.SalesBooth.RequestInfo)
    end
end

function EconomyExploits:UpdateMarketData()
    local timestamp = os.time()
    
    -- Update price history
    for shopType, inventory in pairs(self.Data.ShopInventories) do
        for itemName, itemData in pairs(inventory) do
            if not self.Data.PriceHistory[itemName] then
                self.Data.PriceHistory[itemName] = {
                    prices = {},
                    minPrice = itemData.price,
                    maxPrice = itemData.price,
                    avgPrice = itemData.price
                }
            end
            
            local history = self.Data.PriceHistory[itemName]
            table.insert(history.prices, {price = itemData.price, time = timestamp})
            history.minPrice = math.min(history.minPrice, itemData.price)
            history.maxPrice = math.max(history.maxPrice, itemData.price)
            
            -- Calculate average price
            local total = 0
            for _, priceData in pairs(history.prices) do
                total = total + priceData.price
            end
            history.avgPrice = total / #history.prices
        end
    end
end

function EconomyExploits:AnalyzeMarketTrends()
    local trends = {}
    
    for itemName, history in pairs(self.Data.PriceHistory) do
        if #history.prices >= 5 then
            local recentPrices = {}
            for i = math.max(1, #history.prices - 4), #history.prices do
                table.insert(recentPrices, history.prices[i].price)
            end
            
            local trend = self:CalculatePriceTrend(recentPrices)
            trends[itemName] = trend
        end
    end
    
    self.Data.MarketTrends = trends
end

function EconomyExploits:CalculatePriceTrend(prices)
    if #prices < 2 then return "stable" end
    
    local increases = 0
    local decreases = 0
    
    for i = 2, #prices do
        if prices[i] > prices[i-1] then
            increases = increases + 1
        elseif prices[i] < prices[i-1] then
            decreases = decreases + 1
        end
    end
    
    if increases > decreases then
        return "rising"
    elseif decreases > increases then
        return "falling"
    else
        return "stable"
    end
end

--// UTILITY FUNCTIONS
function EconomyExploits:GetMarketReport()
    local report = {
        totalItems = 0,
        profitableItems = 0,
        avgProfit = 0,
        bestDeals = {},
        marketTrends = self.Data.MarketTrends or {}
    }
    
    local totalProfit = 0
    
    for itemName, itemData in pairs(self.Data.ItemDatabase) do
        report.totalItems = report.totalItems + 1
        
        if isItemProfitable(itemData) then
            report.profitableItems = report.profitableItems + 1
            local profit = calculateProfit(itemData.buyPrice or 0, itemData.sellPrice or 0)
            totalProfit = totalProfit + profit
            
            table.insert(report.bestDeals, {
                item = itemName,
                profit = profit,
                buyPrice = itemData.buyPrice,
                sellPrice = itemData.sellPrice
            })
        end
    end
    
    if report.profitableItems > 0 then
        report.avgProfit = totalProfit / report.profitableItems
    end
    
    -- Sort best deals by profit
    table.sort(report.bestDeals, function(a, b) return a.profit > b.profit end)
    
    return report
end

function EconomyExploits:PrintMarketReport()
    local report = self:GetMarketReport()
    
    print("\n📊 MARKET ANALYSIS REPORT")
    print("═══════════════════════════")
    print("📦 Total Items Tracked: " .. report.totalItems)
    print("💰 Profitable Items: " .. report.profitableItems)
    print("📈 Average Profit Margin: " .. string.format("%.1f%%", (report.avgProfit or 0) * 100))
    
    print("\n🏆 TOP 5 BEST DEALS:")
    for i = 1, math.min(5, #report.bestDeals) do
        local deal = report.bestDeals[i]
        print(string.format("%d. %s - %.1f%% profit (Buy: %d, Sell: %d)", 
            i, deal.item, deal.profit * 100, deal.buyPrice or 0, deal.sellPrice or 0))
    end
    
    if next(report.marketTrends) then
        print("\n📊 MARKET TRENDS:")
        for item, trend in pairs(report.marketTrends) do
            local indicator = trend == "rising" and "📈" or (trend == "falling" and "📉" or "➡️")
            print(indicator .. " " .. item .. ": " .. trend)
        end
    end
end

--// CONTROL FUNCTIONS
function EconomyExploits:StartAllSystems()
    self:StartMarketPriceManipulator()
    self:StartUnlimitedShopRefresh()
    self:StartAutoItemFlipper()
    self:StartFreePurchaseExploit()
    self:StartShopInventoryScanner()
    logActivity("SYSTEM", "All economy exploit systems started")
end

function EconomyExploits:StopAllSystems()
    self:StopMarketPriceManipulator()
    self:StopUnlimitedShopRefresh()
    self:StopAutoItemFlipper()
    self:StopFreePurchaseExploit()
    self:StopShopInventoryScanner()
    logActivity("SYSTEM", "All economy exploit systems stopped")
end

function EconomyExploits:GetStatus()
    return {
        MarketPriceManipulator = self.Config.MarketPriceManipulator,
        UnlimitedShopRefresh = self.Config.UnlimitedShopRefresh,
        AutoItemFlipper = self.Config.AutoItemFlipper,
        FreePurchaseExploit = self.Config.FreePurchaseExploit,
        ShopInventoryScanner = self.Config.ShopInventoryScanner,
        FlipOpportunities = #self.Data.FlipOpportunities,
        TrackedItems = #self.Data.ItemDatabase,
        MinProfitMargin = self.Config.MinProfitMargin * 100 .. "%"
    }
end

--// EMERGENCY FUNCTIONS
function EconomyExploits:EmergencyStop()
    self:StopAllSystems()
    logActivity("EMERGENCY", "Emergency stop activated - all economy systems halted")
end

--// INITIALIZE
function EconomyExploits:Initialize()
    -- Safe initialization with error handling
    local success, error = pcall(function()
        -- Try to connect to RemoteEvents if they exist
        local replicatedStorage = game:GetService("ReplicatedStorage")
        
        -- Check if packages exist
        if replicatedStorage:FindFirstChild("packages") then
            local packages = replicatedStorage.packages
            if packages:FindFirstChild("Net") then
                -- RemoteEvents are available, try to connect
                logActivity("INIT", "RemoteEvents found, connecting...")
                
                -- Safely assign RemoteEvents
                local net = packages.Net
                
                -- Daily Shop
                if net:FindFirstChild("RE") and net.RE:FindFirstChild("DailyShop") then
                    local dailyShop = net.RE.DailyShop
                    self.RemoteEvents.DailyShop.Open = dailyShop:FindFirstChild("Open")
                    self.RemoteEvents.DailyShop.Purchase = dailyShop:FindFirstChild("Purchase")
                    self.RemoteEvents.DailyShop.Refresh = dailyShop:FindFirstChild("Refresh")
                    self.RemoteEvents.DailyShop.ReplicateItems = dailyShop:FindFirstChild("ReplicateItems")
                end
                
                -- Shell Merchant
                if net:FindFirstChild("RE") and net.RE:FindFirstChild("ShellMerchant") then
                    local shellMerchant = net.RE.ShellMerchant
                    self.RemoteEvents.ShellMerchant.Open = shellMerchant:FindFirstChild("Open")
                    self.RemoteEvents.ShellMerchant.Purchase = shellMerchant:FindFirstChild("Purchase")
                    self.RemoteEvents.ShellMerchant.ReplicateItems = shellMerchant:FindFirstChild("ReplicateItems")
                end
                
                -- Commerce
                if net:FindFirstChild("RE") and net.RE:FindFirstChild("Commerce") then
                    local commerce = net.RE.Commerce
                    self.RemoteEvents.Commerce.TryBuy = commerce:FindFirstChild("TryBuy")
                    self.RemoteEvents.Commerce.OpenGui = commerce:FindFirstChild("OpenGui")
                end
                
                logActivity("INIT", "RemoteEvents connected successfully")
            else
                logActivity("INIT", "Net folder not found, running in safe mode")
            end
        else
            logActivity("INIT", "Packages folder not found, running in safe mode")
        end
        
        logActivity("INIT", "Advanced Marketplace & Economy Exploits Module Initialized")
        logActivity("INIT", "Available Features: Price Manipulator, Shop Refresh, Item Flipper, Free Purchase, Inventory Scanner")
    end)
    
    if not success then
        logActivity("ERROR", "Initialization failed: " .. tostring(error))
        logActivity("INIT", "Running in limited mode")
    end
end

return EconomyExploits
